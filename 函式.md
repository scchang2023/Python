# 函式
## 用 def 定義函式
``` python
def do_nothing():
    pass
```
## 用小括號呼叫函式
``` python
do_nothing()

# 定義並呼叫一個沒有參數的函式
def make_a_sound():
    print('quack')
make_a_sound()

# 沒有參數，但回傳一個值的函式
def agree():
    return True

#用 if 呼叫函式，並測試它的回傳值
if agree():
    print('Splendid!')
else:
    print('That was unexpected.')
```
``` python
quack
Splendid!
```
## 引數與參數
在函式外面稱為引數，在裡面為參數。
``` python
# 定義函式，讓它有個 anything 的參數，並return 兩個 anythin 加上一空格
def echo(anything):
    return anything +' '+ anything
echo('Rumplesticltskin')
```
``` python
'Rumplesticltskin Rumplesticltskin'
```
``` python
# 接收一個字串參數color，將說明字串回傳給呼叫方
def commentary(color):
    if color == 'red':
        return 'It is tomato.'
    elif color == 'green':
        return "It's a green pepper."
    elif color == 'bee purple':
        return "I don't know what it is, but only bees can see it."
    else:
        return "I've never heard of the color "+color+"."
comment = commentary('blue')
print(comment)
```
``` python
I've never heard of the color blue.
```
函式沒有明確地呼叫return，呼叫方會得到None
``` python
def do_nothing():
    pass
print(do_nothing())
```
``` python
None
```
### None 是有用的
None是特殊的 python 值，在無話可說時使用。
``` python
thing = None
if thing:
    print("It's some thing")
else:
    print("It's no thing")
# 可以使用 is 運算子來區分 None 與 False
if thing is None:
    print("It's nothing")
else:
    print("Its something")
```
``` python
It's no thing
It's nothing
```
## 位置性引數
``` python
#這函式使用它的位置引數建立一個字典，並傳回它，這很常見，但它的缺點是你必須要記得每一個位置的意思
def menu(wine, entree, dessert):
    return{'wine':wine, 'entree':entree, 'dessert':dessert}
print(menu('chardonnary', 'chicken', 'cake'))
```
``` python
{'wine': 'chardonnary', 'entree': 'chicken', 'dessert': 'cake'}
```
## 關鍵字引數
``` python
#為了避免位置引數造成的混亂，可以用引數對應的參數的名稱來指定引數
def menu(wine, entree, dessert):
    return{'wine':wine, 'entree':entree, 'dessert':dessert}
print(menu(entree = 'beef', dessert='bagel', wine = 'bordeaux'))
```
``` python
{'wine': 'bordeaux', 'entree': 'beef', 'dessert': 'bagel'}
```
## 指定預設參數值
``` python
#為參數指定預設值，在呼叫方沒有提供相應的引數時使用。
def menu(wine, entree, dessert='pudding'):
    return {'wine':wine, 'entree':entree, 'dessert':dessert}
print(menu('chardonnary','chicken'))
#當你提供引數時，函式就會使用它，而不是預設值
print(menu('dunnkelfelder','duck', 'doughnut'))
```
``` python
{'wine': 'chardonnary', 'entree': 'chicken', 'dessert': 'pudding'}
{'wine': 'dunnkelfelder', 'entree': 'duck', 'dessert': 'doughnut'}
```
## 用 * 來炸開 / 收集位置引數
``` python
def print_args(*args):
    print('positional tuple:', args)
#呼叫函式，不傳入引數時，*args不會提供任何東西
print_args()
#傳給它的任何東西都會以 args tuple 印出
print_args(3, 2, 1, 'wait!', 'uh...')
```
``` python
positional tuple: ()
positional tuple: (3, 2, 1, 'wait!', 'uh...')positional tuple: ()
positional tuple: (3, 2, 1, 'wait!', 'uh...')
```
## 用 ** 來炸開 / 收集關鍵字引數
``` python
# 用兩個星星(**)來將關鍵字引數組成字典，其中引數名稱是鍵，它們的值是相應的字典值
def print_kwargs(**kwargs):
    print('keyword arguments:', kwargs)
print_kwargs()
print_kwargs(wine='merlot', entree='mutton', dessert ='macaroon')
```
``` python
keyword arguments: {}
keyword arguments: {'wine': 'merlot', 'entree': 'mutton', 'dessert': 'macaroon'}
```
## 純關鍵字引數
``` python
#在函式定義式裡面的 * 代表接下來的start與end必須用具名引數來提供
def print_data(data, *, start=0, end=100):
    for value in (data[start:end]):
        print(value)
data=['a','b','c','d','e','f']
print_data(data)
print_data(data, start=4)
print_data(data, end=2)
```
``` python
a
b
c
d
e
f
e
f
a
b
```
## 可變與不可變引數
``` python
#這是不好的作法
outside = ['one', 'fine', 'day']
def mangle(arg):
    arg[1] = 'terrible!'
print(outside)
mangle(outside)
print(outside)
```
``` python
['one', 'fine', 'day']
['one', 'terrible!', 'day']
```
## Docstrings
``` python
#你可以在函式內文的開頭加入一個字串來為函式定義加上說明
def echo(anything):
    'echo returns its input argument'
    return anything
#呼叫 help() 可印出函式的 docstring
help(echo)
```
``` python
Help on function echo in module __main__:

echo(anything)
    echo returns its input argument
```
## 函式是一級公民
``` python
def answer():
    print(42)
answer()
# 定義一個函式 run_something，它有一個 func 的引數，是一個要執行的函式，它會在裡面直接呼叫函式。
def run_something(func):
    func()
# 將 answer傳入 run_something()，代表我們把函式當成資料使用。
run_something(answer)
type(run_something)
```
``` python
42
42
function
```
``` python
# 執行函式時傳入引數
# 定義一個函式，讓它印出兩個數字引數的總和
def add_args(arg1, arg2):
    print(arg1+arg2)
# 定義一個函式，它接收三個引數
# func : 要執行的函式
# arg1：傳給func的第1個引數
# arg2：傳給func的第2個引數
def run_something_with_args(func, arg1, arg2):
    func(arg1,arg2)
run_something_with_args(add_args, 5, 9)
```
``` python
14
```
``` python
#定義一個測試函式，讓它接收任意數量的引數，並使用 sum() 函式來計算他們的總合並回傳：
def sum_args(*args):
    return sum(args)
def run_with_position_args(func, *args):
    return func(*args)
run_with_position_args(sum_args, 1, 2, 3, 4)
```
``` python
10
```
## 內部函式
在另一個函式裡面定義一個函式
``` python
#在另一個函式裡面定義一個函式
def outer(a, b):
    def inner(c, d):
        return c+d
    return inner(a, b)
outer(4,7)
```
``` python
11
```
要在一個函式執行複雜的動作，可以使用內部函式來避免編寫重複的迴圈或程式碼
``` python
def knights(saying):
    def inner(quote):
        return "we are the knights who say: '%s'" % quote
    return inner(saying)
knights('Ni!')
```
``` python
"we are the knights who say: 'Ni!'"
```
### Closure
內部函式可以當成 closure 使用，它是用其他的函式動態產生的函式
``` python
# 與 knights 的差異如下：
# inner2()可以直接使用外面得saying參數，不需要用引數來取得
# knigghts2()會回傳inner2函式名稱，而不是呼叫它
def knights2(saying):
    def inner2():
        return "we are the knights who say: '%s'" % saying
    return inner2
a = knights2('Duck')
b = knights2('Hasenpfeffer')
# a 跟 b 是函式，也是 closure
print(type(a), type(b))
print(a, b)
# 當我們呼叫它們是，它們會記得自己被 knights2 建立時使用的saying
print(a(), b())
```
``` python
<class 'function'> <class 'function'>
<function knights2.<locals>.inner2 at 0x00000198284FFF60> <function knights2.<locals>.inner2 at 0x00000198284FFEC0>
we are the knights who say: 'Duck' we are the knights who say: 'Hasenpfeffer'
```
## 匿名函式：lambda
以一行陳述式來表示的匿名函式。可以用它來取代一般的小函式
``` python
# 一般函式，它的引數是
# words：單字串列
# func：處理words裡面的各各單字函式
def edit_story(words, func):
    for word in words:
        print(func(word))
stairs = ['thud', 'meow', 'thd', 'hiss']
def enliven(word):
    return word.capitalize()+'!'
edit_story(stairs, enliven)

# 來寫lambda，因為enliven很短
edit_story(stairs, lambda word: word.capitalize()+'!')
```
``` python
Thud!
Meow!
Thd!
Hiss!
Thud!
Meow!
Thd!
Hiss!
```
## 產生器
python序列製作物件，可以用它來迭代可能很大的序列。
``` python
sum(range(1, 101))
```
``` python
5050
```
### 產生器函式
如要建立龐大的序列，自己編寫產生器函式。用yield陳述式來回傳值，而不是return。
``` python
def my_range(first=0, last=0, step=1):
    number = first
    while number < last:
        yield number
        number+=step
# 它是個一般函式
print(my_range)
# 回傳一個產生器物件
ranger = my_range(1, 5)
print(ranger)
# 可以迭代這個產生器物件
for x in ranger:
    print(x)
```
``` python
<function my_range at 0x00000179ADF3EDE0>
<generator object my_range at 0x00000179ADF5F3E0>
1
2
3
4
```
## 裝飾器
- 想要修改既有的函式，但不想更改它的原始碼，常見的情況是加入一個除錯陳述式來查看哪些引數被傳入。
- 裝飾器 (decorator)是一種函式，它會接收一個函式，並回傳另一個函式。